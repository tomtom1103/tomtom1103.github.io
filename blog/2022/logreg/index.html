<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Logistic Regression | Jonghyun (Thomas) Lee </title> <meta name="author" content="Jonghyun (Thomas) Lee"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="deep generative models"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/apple-touch-icon-precomposed.png?f3b0e00b51d3560daeef2cfef2a1c566"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tomtom1103.github.io/blog/2022/logreg/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?ac1a8a24b4b1b97e0b04e951186c207f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jonghyun</span> (Thomas) Lee </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/portfolio/">portfolio </a> </li> <li class="nav-item"> <a class="nav-link" href="/assets/pdf/Tom_Resume_0812.pdf" target="_blank" rel="noopener noreferrer">cv <span class="sr-only">(current)</span> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Logistic Regression</h1> <p class="post-meta"> June 30, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/category/machine-learning"> <i class="fa-solid fa-tag fa-sm"></i> machine-learning</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="contents">Contents</h2> <ul> <li>Logistic Regression</li> <li>Odds and the Logit Function</li> <li>Learning and Maximum Likelihood Estimation</li> </ul> <blockquote> <p>해당 포스트는 2021년 1학기 고려대학교 강필성 교수님의 ‘<a href="https://github.com/pilsung-kang/multivariate-data-analysis" rel="external nofollow noopener" target="_blank">다변량분석</a>’ 강의를 참고하여 작성되었습니다.</p> <p>이미지는 강필성 교수님의 강의 슬라이드에서 발췌하였습니다.</p> <p><del>A+ 감사했습니다 교수님</del></p> </blockquote> <h2 id="logistic-regression">Logistic Regression</h2> <p><br> 로지스틱 회귀분석은 전 장에서 살펴본 다중선형회귀분석을 차용한 모델이다. 다중선형회귀분석의 종속변수의 범위는 연속적인 실수값이지만, 로지스틱 회귀분석은 종속변수가 binary 하다.</p> \[MLR: \hat y = \hat \beta_0 + \hat \beta_1 x_1 + \hat \beta_2x_2 + ... + \hat \beta_dx_d\] <p>다중선형회귀분석의 식을 그대로 binary \(\hat y\) 값을 추정하는데 사용한다면 한가지 문제가 생긴다. 우변은 연속적인 값을 표현하는데 사용되지만, 좌변은 binary 하기 때문에 구한 회귀식의 범위가 종속변수의 범위를 벗어난다. 그렇기 때문에 로지스틱 회귀분석은 약간의 수학적 트릭을 사용해서 다중선형회귀분석의 우변의 꼴을 유지하면서 binary 종속변수를 표현할 수 있게 한다.</p> <blockquote> <p>로지스틱 회귀분석에서 ‘회귀식’의 꼴을 유지하는데 있어 몇가지 장점이 있다.</p> <ol> <li>추정된 \(\hat \beta\) 값을 통해 설명변수의 유의미도를 파악할 수 있다.</li> <li>해당 설명변수를 통해 최종 확률이 증가하는지/감소하는지 파악할 수 있다.</li> </ol> </blockquote> <p>회귀식의 꼴을 유지하면 위와 같이 모델의 설명력을 그대로 유지할 수 있다는 장점이 있다. 그렇기 때문에 로지스틱 회귀분석은 y 에 대한 ‘logit’ 함수를 통해 설명변수와의 선형결합을 표현 할 수 있다.</p> <h2 id="odds-and-the-logit-function">Odds and the Logit Function</h2> <p><br> 로지스틱 회귀분석을 알기 위해 먼저 Odds (승산) 의 개념을 익혀야 한다. 승산은 스포츠 중계에서 흔하게 볼 수 있는 수치로, ‘‘해당 팀의 승산이 몇대몇 (ex. 9:2) 이다’ 로 표현된다.</p> \[Odds = {p \over 1-p} = {P(Success) \over P(Failure)}\] <p>예시를 들어보자. 2010년 월드컵에서 전문가들은 스페인의 ‘승산’이 9:2 라고 산출했다. 이를 승산식에 넣으면 p, 즉 우승 확률을 구할 수 있다.</p> \[Odds = {p \over 1-p} = {2 \over 9} \\ 9p = 2-2p \\ p = {2 \over 11}\] <p>로지스틱 회귀분석은 바로 이 승산을 도입해서 binary 값을 연속형으로 표현하는데 사용한다.</p> <table> <thead> <tr> <th>Equation</th> <th>Explanation</th> </tr> </thead> <tbody> <tr> <td>\(y \in \{0,1\}\)</td> <td>기존 종속변수는 binary 값이다.</td> </tr> <tr> <td>\(P(y=1) \in [0,1]\)</td> <td>종속변수가 1일 확률을 종속변수로 지정하여 0과 1 사이 연속적인 값으로 표현한다.</td> </tr> <tr> <td>\(p = P(y=1)\)</td> <td>종속변수가 1일 확률을 Odds 의 p 로 치환한다.</td> </tr> <tr> <td>\(0 \leq {p \over 1-p} \leq \infty\)</td> <td>종속변수의 값의 범위가 0부터 \(\infty\) 로 변한다.</td> </tr> <tr> <td>\(-\infty \leq ln{p \over 1-p} \leq \infty\)</td> <td>Odds 에 로그를 씌워 범위를 실수로 확장한다.</td> </tr> </tbody> </table> <p>먼저 종속변수의 binary 값 중 1일 확률을 Odds 와 비교하면 아래의 그래프와 같다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/machinelearning/logreg/img1-480.webp 480w,/assets/img/posts/machinelearning/logreg/img1-800.webp 800w,/assets/img/posts/machinelearning/logreg/img1-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/posts/machinelearning/logreg/img1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>종속변수를 Odds 로 설정하면 범위가 0부터 무한대로 늘어난다. Even 이라고 되어있는 지점은 P(y=1) = 0.5 이고, 대응하는 Odds 값은 1이다. 하지만 Odds 는 비대칭이고 \(-\infty\) 를 표현하지 못하기 때문에, 로그함수를 씌워준다.</p> \[p=0 \rightarrow Odds \rightarrow 0 \rightarrow ln \rightarrow -\infty \\ p=1 \rightarrow Odds \rightarrow \infty \rightarrow ln \rightarrow \infty\] <p>위와 같이 0과 1 사이의 확률을 승산의 로그함수에 대입하니 범위가 모든 실수로 확장되는 것을 볼 수 있다. 이를 logit function 이라 한다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/machinelearning/logreg/img2-480.webp 480w,/assets/img/posts/machinelearning/logreg/img2-800.webp 800w,/assets/img/posts/machinelearning/logreg/img2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/posts/machinelearning/logreg/img2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>즉, 회귀식의 우변의 꼴을 유지하면서 binary 한 종속변수를 표현 할 수 있게 된 것이다.</p> \[ln(Odds) = ln({p \over 1-p}) = \hat \beta_0 + \hat \beta_1x_1 + \hat \beta_2x_2+...+\hat \beta_dx_d\] <p>위 식은 성공확률에 대한 로그승산을 선형식으로 추정한 것이다. 하지만 회귀식을 추정하는 이유는 새로운 데이터포인트가 들어오면 이에 대한 정의한 확률 \(P(y=1)\) 을 알고 싶은 것이기 때문에, 위의 회귀식을 p 에 대해서 정리해야 한다.</p> \[{p \over 1-p} = e^{\hat \beta_0 + \hat \beta_1x_1 + \hat \beta_2x_2+...+\hat \beta_dx_d} \\ p = {1 \over 1+e^{-\hat \beta_0 + \hat \beta_1x_1 + \hat \beta_2x_2+...+\hat \beta_dx_d}} \\ \sigma(x|\beta)\] <p>위 식으로 새로운 데이터포인트가 들어오면 정의한 1범주에 속할 확률을 구할 수 있다. 자세히 보면 \(\hat\beta_0\) 상수가 0이고 1차원의 설명변수의 계수가 1이면 식은 Sigmoid Function 이 된다. <strong>확률에 대한 해당 식은 \(\sigma (x \mid \beta)\) 라고 표현하기도 하고, 실제 그래프상 그려지는 함수다.</strong></p> <h2 id="learning-and-maximum-likelihood-estimation">Learning and Maximum Likelihood Estimation</h2> <p><br> 앞서 살펴본 다중선형회귀분석은 closed form solution 이 존재하는 몇 안되는 알고리즘 중 하나다. \(\hat \beta = (X^TX)^{-1}X^TY\) 의 행렬연산을 통해 명시적 \(\hat \beta\) 의 값을 구할 수 있지만, 로지스틱 회귀분석은 그렇지 않다. 로지스틱 회귀분석은 학습과정에서 항상 다른 모델이 학습되기 때문에, 이 과정을 살펴보고자 한다.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/machinelearning/logreg/img3-480.webp 480w,/assets/img/posts/machinelearning/logreg/img3-800.webp 800w,/assets/img/posts/machinelearning/logreg/img3-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/posts/machinelearning/logreg/img3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p><br> 위에 같은 데이터셋으로 학습된 두개의 로지스틱 회귀분석 모델이 있다. Label 1 은 불량제품이며, Label 0 은 정상제품이다. 이 두개의 모델 중 더 나은 모델을 고르자면 모델 A다. 모델 A와 B 모두 정답 Label 에 더 높은 확률을 부여했지만 (맞게 예측했지만), <strong>모델 A 는 정답범주에 속할 확률을 더 높게 산출하고 있기 때문에 더 나은 모델이라고 할 수 있다.</strong></p> <p>이를 우도(Likelihood) 라고 하며, 베이즈 정리에서 등장하는 \(P(Evidence \mid Hypothesis)\) 다. <strong>만약 데이터셋의 모든 샘플들이 독립적으로 생성되었다고 가정하면 (iid assumption), 데이터셋에 대한 전체 우도는 모든 샘플의 우도의 곱으로 계산된다.</strong></p> \[if \ A \cap B = \varnothing, \\ P(AB) = P(A)P(B)\] <p>그렇기 때문에 같은 데이터셋을 통해 생성된 두개의 로지스틱 회귀분석 모델을 비교할 시, 데이터셋의 우도를 통해 어떤 모델이 더 나은지 비교할 수 있다. 하지만 우도는 각 샘플의 우도의 곱으로 계산되기 때문에, 실제 데이터셋의 샘플크기가 많아질수록 0에 수렴한다. 이를 방지하기 위해 로그를 씌운다.</p> <p>우도를 통해 모델의 성능을 비교할 수 있지만, 반대로 생각해보면 이를 cost function 으로 사용해 모델을 학습시킬 수도 있다. 이를 MLE (Maximum Likelihood Estimation) 이라 하며, 우도를 최대화 시키는 \(\hat \beta\) 값을 찾도록 학습시키는 것이다.</p> \[P(\textbf{x}_i,y_i|\beta) =\sigma(\textbf{x}_i|\beta)^{y_i}(1-\sigma(\textbf{x}_i|\beta))^{1-y_i}\] <p>각 샘플의 우도를 구하는 식은 위와 같다. Integer programming 에서 사용되는 트릭과 비슷하게 \(y_i\) 가 1일때 우변의 앞부분이 활성화되고, \(y_i\) 가 0이면 뒷부분이 활성화되도록 formulating 한 것이다. 이때 앞서 언급한 것 처럼 \(\sigma(X_i \mid \beta)\) 는 \(p = {1 \over 1+e^{-\hat \beta_0 + \hat \beta_1x_1 + \hat \beta_2x_2+...+\hat \beta_dx_d}}\) 이다. 즉, 해당 샘플의 Label 이 타깃 Label (\(y_i=1\)) 이면 확률을 구하고, 타깃 Label 이 아니면 1에서 확률을 뺀 것으로 해당 샘플의 우도를 구할 수 있다. 각 샘플의 우도를 구하는 식으로 데이터셋의 우도를 구하는 식은 다음과 같다.</p> \[L(\textbf{X},\textbf{y}|\beta) = \prod^N_{i=1} P(\textbf{x}_i,y_i|\beta) = \prod^N_{i=1}\sigma(\textbf{x}_i|\beta)^{y_i}(1-\sigma(\textbf{x}_i|\beta))^{1-y_i}\] <p>앞서 언급한 것 처럼 데이터셋의 우도는 iid 가정 하에 모든 샘플의 우도의 곱이다.</p> \[logL(\textbf{X},\textbf{y}|\beta) = \sum y_i log\sigma(\textbf{x}_i|\beta)+(1-y_i)log(1-\sigma(\textbf{x}_i|\beta))\] <p>양변에 로그를 취해주면 product 는 summation 이 되므로 위의 식이 된다. 위 식으로 데이터셋의 우도를 최대화 시키는 \(\hat \beta\) 를 구하는 것이 MLE 다. MLE 를 loss function 으로 사용 할 경우 Gradient Descent 를 사용하는 경우가 많다.</p> <p>최종적으로 우도를 최대화 시키는 회귀식을 구하면, 새로운 샘플에 대해 해당 샘플이 타깃 Class 에 속해있을 확률을 구할 수 있다. 하지만 로지스틱 회귀분석의 목적은 결과적으로 binary classification 이기 때문에, Cutoff 를 정해야 한다. 즉, 어느정도의 확률 이상만 타깃 Class 라고 분류해주는 Cutoff 를 설정해야 한다. 가장 많이 사용되는 cutoff 는 직관적이게 0.5 다. <strong>하지만 실제 상황에선 특정 구간 내 설명변수와 종속변수는 정비례하지만 구간을 벗어나면 설명변수가 확률에 영향을 끼치는 정도가 작아진다.</strong> 그렇기 때문에 해당 데이터셋이 만들어진 상황과 목적에 따라 cutoff 를 설정해야 한다. 예시로 불량을 잡아내는게 매우 중요한 QC 같은 분야에선 타깃 Class 가 1이면, cutoff 를 매우 낮게 잡아 (ex. 0.2) 아주 작은 확률도 불량이라고 정하는게 중요하다.</p> </div> </article> </div> </div> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>